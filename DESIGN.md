When it comes to password cracking, attackers use a variety of techniques to increase their chances of success. Beyond simply trying uppercase and lowercase variations, here are two common methods:

1. **Appending Common Numbers or Symbols**: A lot of people add simple numbers or symbols at the end of their passwords, like "123", "!", or "2023". To implement this in a password cracker, I’d modify my code to generate and append commonly used number sequences and symbols to the original password guesses, adding these variations to the list of guesses for the brute-force attempt.

2. **Leet Speak Substitution**: In leet speak, certain letters are replaced with similar-looking numbers or symbols (for example, "e" becomes "3", "a" becomes "4", and "o" becomes "0"). This makes it easy for people to remember passwords while adding perceived complexity. In code, I would add a function that substitutes letters with these common leet equivalents and apply it to each password guess, adding these "leeted" variations to the guesses being tested.

As for working memory requirements, the amount of memory needed depends on the number of variables and the length of the password guesses being stored. Generally, password crackers are *not* memory-limited; they’re far more limited by processing speed, as trying each guess requires considerable computation. This is especially true when hashing or encryption algorithms are involved, which are designed to be time-intensive. Thus, a password cracker's effectiveness typically hinges on processing power rather than memory capacity.